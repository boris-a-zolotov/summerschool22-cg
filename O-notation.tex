\section{O-нотация}

\subsection{Определение}

\begin{frame}{Идея \(O\)}
	Пусть некоторая программа принимает на вход данные. \\
	Она, скорее всего, работает тем дольше, чем больше \\
	данных поступило на вход. Мы хотим оценить время работы \\
	программы, сравнивая его с известными функциями \(\bn \to \bn\).
\end{frame}


\begin{frame}{Определение из анализа}
\begin{defn}
	Функции \(f,\ g\,\colon\ \br \to \br\). Говорят, что
		\[f(x) = O(g(x)),\ \ \text{если}\ \ \exists\,C\ \forall\,x\ 
			|f(x)| \le C \cdot |g(x)|. \]
\end{defn}
\end{frame}


\begin{frame}{Определение для нас} \ \\
\begin{defn}
	Время работы программы составляет \(O(f(n))\), если \\
	существует \(C\): для входа {\it размера \(n\)} количество операций \\
	составит не более \(f(n) \cdot C\).
\end{defn}

\begin{itemize}
	\item Какие операции считаются в данном определении, \\
	      обычно известно из контекста.
	\item Если вход состоит из {\it одного числа,} размер \\
	      входа равен 1, вне зависимости от величины числа.
\end{itemize}
\end{frame}

\subsection{Максимум в массиве}

\begin{frame}{Поиск наибольшего элемента в массиве} \ \\
\begin{task}
	Дан массив из \(n\) целых чисел, найти в нём наибольший элемент.
\end{task}

Отсмотрим все элементы по порядку, храня наибольший \\
отсмотренный элемент. Мы обращаемся к каждому элементу \\
по разу, поэтому \(O(n)\). Быстрее, очевидно, нельзя.
	\input{img/maximum}
\end{frame}

\subsection{Элемент в отсортированном массиве}

\begin{frame}{Наличие элемента в отсортированном массиве} \ \\
\begin{task}
	Дан массив \(M\) из \(n\) целых чисел, они упорядочены по возрастанию. \\
	Дано число \(k\)~— проверить, есть ли оно в \(M\).
\end{task}

Сравним \(k\) и элемент в середине \(M\)~— назовём его \(m\). \\
Если \(m>k\), ищем в первой половине массива. Иначе во второй.
	\input{img/binsearch}
\end{frame}

\begin{frame}{Как оценить время работы}
	Пусть \(T(n)\)~— время работы на массиве из \(n\) элементов. Тогда
	\[ T(n) = 1 + T\lr*{\frac{n}{2}}.\]

	Отсюда \[ T(n) = O\lr*{\log_2 \lr*{n}}.\]
\end{frame}

\subsection{Количество комнат на корабле}

\begin{frame}{Количество комнат на космическом корабле} \ \\
\begin{task}
	Космический корабль в форме кольца разделён на \(n\) \\
	одинаковых комнат, в которых горит или не горит свет. \\
	Можно переходить между соседними комнатами, \\
	включать или выключать свет. Найти \(n\).
\end{task} \medskip

\begin{center} \tikz{
	\torship001100101 \me5
} \end{center}
\end{frame}


\begin{frame}{Простое решение}
	Процедура \(\text{проход}\lr*{k}\)~— пройти на \(k\) комнат вперёд, включая \\
	в каждой комнате свет (может быть что угодно).

	Потом пройти на \(k\) комнат назад, выключая в каждой \\
	комнате свет (должен быть включен).

\begin{center} \tikz{
	\torship011110101 \me2
	\draw[thick,Violet,->] (-95:1.6) arc (-95:-205:1.6);
} \hspace{2cm} \tikz{
	\torship000000101 \me5
	\draw[thick,Violet,<-] (-95:1.6) arc (-95:-205:1.6);
} \end{center}
\end{frame}


\begin{frame}{Оценка времени}
	Выполним \(\text{проход}\lr*{1}, \text{проход}\lr*{2}, \text{проход}\lr*{3}, \ldots\)

	В какой-то момент мы вернёмся, чтобы выключить свет \\
	в первой комнате, а он уже будет там выключен. \\
	Значит, мы прошли полный круг.
	\[2 \cdot (1+2+\ldots+n) = O\lr*{n^2}\text{\ \ переходов.}\]
\end{frame}


\begin{frame}{Решение за линейное время {\it (Doubling search)}}
	Пусть \(2^{k-1} \le n < 2^k\).

	Выполним \(\text{проход}\lr*{1}, \text{проход}\lr*{2},\ldots,
	\text{проход}\lr*{2^i},\ldots\)

	Каждый раз длина прохода увеличивается в два раза. \\
	В какой-то момент на обратном пути мы придём \\
	в комнату, свет в которой уже выключен.
	\[2 \cdot \lr*{1+2+4+\ldots+2^k}\ =\ 2 \cdot \lr*{2^{k+1}-1}\ 
		\le\ 8 \cdot n\ =\ O(n).\]
\end{frame}

\subsection{Алгоритм Беллмана — Форда}

\begin{frame}{Алгоритм Беллмана — Форда}
\begin{task}
	Дан граф \(G = \lr*{V,E}\), на рёбрах расставлены неотрицательные \\
	веса. Выбрана \(v \in V\), найти наименьшие веса путей от \(v\) \\
	до каждой из остальных вершин.
\end{task}

Изначально \(d(v_i) = +\infty\) для всех \(v_i\).
\end{frame}


\begin{frame}{Идея} \ \\ [-0.3cm]
\begin{center} \input{img/bellmanfordex}
{\footnotesize \textcolor{white!46!dgray}{Считаем, что все \(d(v_i)\)
	обновляются одновременно.
	В реальности дело чуть лучше.}} \end{center}
\end{frame}


\begin{frame}{Улучшение \(d(v_i)\)}
\begin{center} \begin{algorithmic}
   \For{\(i=1\) to \(|V| - 1\)}
      \ForAll{\(e = (u_1,u_2) \in E\)}
         \If{\(d(u_1) + \text{weight}(e) < d(u_2)\)} \\
            \qquad\qquad \(d(u_2) \leftarrow d(u_1) +  \text{weight}(e)\)
            \Comment{Пытаемся с помощью ребра \(e\)\\ \hfill улучшить путь в \(v_2\)}
         \EndIf
      \EndFor \Comment{Нашли оптимальные пути длины \(\le i\)}
   \EndFor
\end{algorithmic} \end{center}
\end{frame}


\begin{frame}{Асимптотика с несколькими параметрами}
	Время работы оценивается как \(O\lr*{ |V| \cdot |E| }\).

	Мы, конечно, знаем, что \(|V| \le |E|+1\) и \(|E| \le |V|^2\), \\
	но зачастую нам нужна точная оценка \\
	относительно обоих параметров входа.
\end{frame}

\subsection{Замечания}

\begin{frame}{Замечания}
\begin{itemize}
	\item \( \log_a n\ \ll\ n^k\ \ll\ a^n \) \bigskip
	\item \( \log_a n\ \sim\ \log_b n \) \bigskip
	\item \( \log_a \lr*{x^k}\ \sim\ \log_a x \)
\end{itemize}
\end{frame}
